###### Phoenix Compiler ######
println("Compiler start");;

#### Reader
def simple_symbols = {
  '+' => "+", '*' => "*", '/' => "/",  '-' => "-", '%' => "%", '!' => "!",
  '(' => "(", ')' => ")", '{' => "{", '}' => "}",
  '[' => { true=>"[", '|'=>"[|"}, ']' => "]", '|' => {']' => "|]"},
  '=' => {'=' => "==", '>' => "=>", true => "="},
  '<' => {'=' => "<=", true => "<="},
  '>' => {'=' => ">=", true => ">="},
  '&' => {'&' => "&&"}, '|' => {'|' => "||"},
  ';' => {';' => ";;", true => ";"},
  ':' => {':' => "::", '='=>":=", true => ":"},
  ',' => ","
};;

def keywords = {
  "if" => "if",
  "then" => "then",
  "else" => "else",
  "def" => "def",
  "defn" => "defn",
  "fn" => "fn",
  "true" => true,
  "false" => false
};;

defn reader_new file =
  def src  = if file?(file) then file else if string?(file) then open!(file, "r") else exit(-1);
  {"src" => src, "column" => 0, "line" => 1, "cur" => readchar!(src)}
;;

defn reader_next reader =
  insert!(reader, "column", get(reader, "column") + 1);
  insert!(reader, "cur", readchar!(get(reader, "src")))
;;
  

defn reader_inc_lines reader =
  insert!(reader, "line", get(reader, "line") + 1);
  insert!(reader, "column", 0)
;;

defn reader_create_token reader name val =
  { "tok"=>name, "val"=>val, "col" =>get(reader, "column"), "line"=>get(reader, "line") }
;;

defn reader_waste_comment reader =
  def c = get(reader, "cur");
  if c == '\n' then []
  else (reader_next(reader); reader_waste_comment(reader))
;;
  
  
defn reader_next_number reader =
  (defn get_num =
    def n = ord(get(reader, "cur")) - ord('0');
    reader_next(reader);
    if char_number?(get(reader, "cur")) then n * 10 + get_num()
    else n);
  reader_create_token(reader, "int", get_num())
;;

defn reader_next_symbol reader map =
  def c = get(reader, "cur");
  if has(map, c) then
    def v = get(map, c);
    if string?(v) then (reader_create_token(reader, "op", v) : reader_next(reader))
    else (reader_next(reader); reader_next_symbol(reader, v))
  else if has(map, true) then reader_create_token(reader, "op", get(map, true))
  else reader_create_token(reader, "error", "invalid symbol sequence")
;;

defn identifier_start_char c =
  between('a', c, 'z') ||
  between('A', c, 'Z') ||
  c == '@' ||
  c == '?' ||
  c == '$' ||
  c == '_'
;;

defn identifier_char c =
  identifier_start_char(c) ||
  between('0', c, '9') ||
  c == '!'
;;
  
defn reader_identifier_or_keyword reader =
  (defn read_ident = 
    def c = get(reader, "cur");
    if identifier_char(c) then reader_next(reader); c + read_ident()
    else "");
  def id = read_ident();
  if has(keywords, id) then reader_create_token(reader, "keyword", get(keywords, id))
  else reader_create_token(reader, "identifier", id)
;;

defn reader_string reader escaped end =
    reader_next(reader);
    def c = get(reader, "cur");
    if escaped then
      if c == 'n' then "\n" + reader_string(reader, false, end)
      else if c == '\\' then "\\" + reader_string(reader, false, end)
      else if c == 't' then "\t" + reader_string(reader, false, end)
      else c + reader_string(reader, false, end)
    else if c == end then ""
    else if c == '\\' then reader_string(reader, true, end)
    else c + reader_string(reader, false, end)
;;
defn reader_next_string reader =
  reader_create_token(reader, "string", reader_string(reader, false, '"')):
  reader_next(reader)
;;

defn reader_next_char reader =
  def str = reader_string(reader, false, '\'');
  if length(str) == 1 then (
    reader_create_token(reader, "char", str):
    reader_next(reader)
  ) else reader_create_token(reader, "error", "too many chars in char literal")
;;
  

defn reader_next_token reader =
  def c = get(reader, "cur");
  if eof?(c) then reader_create_token(reader, "error", "eof")
  else if c == ' ' then reader_next(reader); reader_next_token(reader)
  else if c == '\n' then reader_inc_lines(reader); reader_next(reader); reader_next_token(reader)
  else if c == '#' then reader_waste_comment(reader); reader_next_token(reader)
  else if c == '"' then reader_next_string(reader)
  else if c == '\'' then reader_next_char(reader)
  else if has(simple_symbols, c) then reader_next_symbol(reader, simple_symbols)
  else if identifier_start_char(c) then reader_identifier_or_keyword(reader)
  else if char_number?(c) then reader_next_number(reader)
  else reader_create_token(reader, "error", "unknown token")
;;

#### Parser
defn parser_new reader =
  { "reader"=>reader, "cur" => reader_next_token(reader), "next" => reader_next_token(reader) }
;;

defn parser_next parser =
  insert!(parser, "cur", get(parser, "next"));
  insert!(parser, "next", reader_next_token(get(parser, "reader")))
;;

defn parser_cur parser =
  get(parser, "cur")
;;

defn printloc parser =
  def t = parser_cur(parser);
  def line = get(t, "line");
  def col = get(t, "col");
  print("loc:");
  print(line);
  print(":");
  print(col);
  print(" ")
;;

defn parser_expect parser tok val =
  def c = get(parser, "cur");
  (defn error =
    printloc(parser);
    print("Expected [");
    print(val);
    print("] but got [");
    print(get(c, "val"));
    println("]")
  );
  if get(c, "tok") == tok && get(c, "val") == val then parser_next(parser)
  else (error(); exit(1))
;;


defn create_binexpr op left right = [|"binary", op, left, right|];;
defn create_uniexpr op expr = [|"unary", op, expr|];;
defn create_ifexpr cond ethen eelse = [|"if", cond, ethen, eelse|];;
defn create_defexpr name expr = [|"def", name, expr|];;
defn create_fnexpr args expr = [|"fn", args, expr|];;
defn create_defnexpr name args expr = create_defexpr(name, create_fnexpr(args, expr));;
defn create_callexpr name args = [|"call", name, args|];;
defn create_litexpr val = remove!(val, "tok"); [|"lit", val|];;

def precedence = {
  "!"  => 110,
  "*"  => 100,
  "/"  => 100,
  "%"  => 100,
  "-"  => 90,
  "+"  => 90,
  "::" => 80,
  "<"  => 70,
  ">"  => 70,
  "==" => 60,
  "<=" => 60,
  ">=" => 60,
  "&&" => 50,
  "||" => 40,
  ":=" => 30,
  "="  => 20,
  ";"  => 10,
  ":"  => 10
};;

defn parse_atom parser =
  def c = parser_cur(parser);
  parser_next(parser);
  if get(c, "tok") == "int" then create_litexpr(c)
  else if get(c, "tok") == "string" then create_litexpr(c)
  else if get(c, "tok") == "keyword" then create_litexpr(c)
  else (print("Unexpected atom: "); println(get(c, "val")); exit(-1))
;;


defn parse_unary parser =
  def c = parser_cur(parser);
  if get(c, "tok") == "op" then
    parser_next(parser);
    if get(c, "val")      == "-" then create_uniexpr(get(c, "val"), parse_unary(parser))
    else if get(c, "val") == "!" then create_uniexpr(get(c, "val"), parse_unary(parser))
    else (printloc(parser); print("bad unary operator:"); println(get(c, "val")); exit(1))
  else
    parse_atom(parser)
;;

defn parse_partial_binary parser prec left = 
  def t = parser_cur(parser);
  if get(t, "tok") == "op" && has(precedence, get(t, "val")) then (
    def nprec = get(precedence, get(t, "val"));
    if nprec > prec then (
      parser_next(parser); # skip current operator
      def right = parse_binary(parser, nprec);
      create_binexpr(t, left, right)
    ) else left
  ) else
    left
;;

defn parse_binary parser prec =
  def left = parse_unary(parser);
  (defn loop parser prec left =
    def t = parser_cur(parser);
    if get(t, "tok") == "op" &&
       has(precedence, get(t, "val")) &&
       get(precedence, get(t, "val")) > prec
    then loop(parser, prec, parse_partial_binary(parser, prec, left))
    else left);
  loop(parser, prec, left)
;;

defn parse_if parser =
  parser_expect(parser, "keyword", "if"); # skip if
  def cond = parse_expr(parser);
  parser_expect(parser, "keyword", "then"); # skip then
  def ethen = parse_expr(parser);
  parser_expect(parser, "keyword", "else"); # skip else
  def eelse = parse_expr(parser);
  create_ifexpr(cond, ethen, eelse)
;;

defn parse_def parser =
  parser_expect(parser, "keyword", "def"); # skip def
  def name = parser_cur(parser);
  parser_next(parser); # skip name
  parser_expect(parser, "op", "="); # skip =
  def expr = parse_expr(parser);
  create_defexpr(name, expr)
;;

defn parse_defn parser =
  []
;;

defn parse_fn parser =
  []
;;

defn parse_expr parser =
  def c = parser_cur(parser);
  if get(c, "tok") == "keyword" then 
    if get(c, "val") == "defn" then parse_defn(parser)
    else if get(c, "val") == "if" then parse_if(parser)
    else if get(c, "val") == "fn" then parse_fn(parser)
    else if get(c, "val") == "def" then parse_def(parser)
    else parse_binary(parser, 0)
  else parse_binary(parser, 0)
;;
  


defn parse_stmt parser =
  parse_expr(parser):
  parser_expect(parser, "op", ";;")
;;



#dotimes(fn = println(reader_next_token(reader)), 7);;
def reader = reader_new($stdin);;
def parser = parser_new(reader);;
println(parse_stmt(parser));;
